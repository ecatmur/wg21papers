\input{wg21common}

\begin{document}
\title{Functions with a narrow contract should not be \tcode{noexcept}}
\author{ Timur Doumler \small(\href{mailto:papers@timur.audio}{papers@timur.audio})   \\
Ed Catmur \small(\href{mailto:papers@timur.audio}{papers@timur.audio})  }
\date{}
\maketitle

\begin{tabular}{ll}
Document \#: & D2831R0 \\
Date: &2023-03-16 \\
Project: & Programming Language C++ \\
Audience: & Library Evolution Working Group
\end{tabular}

\begin{abstract}
The Lakos Rule is a longstanding design principle in the C++ Standard Library. It stipulates that a function having a narrow contract should not be \tcode{noexcept}, even if it is known to not throw when called with valid input. This paper presents a case study showing why the Lakos Rule is still useful and important today and why we should not remove it, at least not until we have standardised a C++ Contracts facility that offers a superior alternative.
\end{abstract}

\section{Introduction}
\label{sec:intro}

C++ functions --- in the Standard Library or in other places --- can have \emph{preconditions}, which are a form of \emph{contract}. A function that has no preconditions on its input (parameter) values or on the state accessible from it (object state or global state) --- i.e., a function that has defined behaviour for any combination of input values and accessible state --- is said to have a \emph{wide contract}. An example of such functions in the C++ Standard Library are \tcode{std::vector::at} and \tcode{std::vector::size}.

If such a function is required never to throw an exception (or if it is somehow known that it will never throw an exception), it may be declared \tcode{noexcept} (conditionally or unconditionally). This is the case for \tcode{std::vector::size}.

By contrast, a function that has preconditions --- i.e., a function that has undefined behaviour for some combination of input values and accessible state, which we consider \emph{invalid} --- is said to have a \emph{narrow contract}. An example of such functions in the C++ Standard Library are \tcode{std::vector::operator[]} and \tcode{std::vector::front}. The behaviour is undefined for passing an out-of-bounds index to the former, as well as for invoking either of the two functions on an empty \tcode{std::vector}.

A longstanding design principle in the C++ Standard Library has been that a function having a narrow contract should not be marked as \tcode{noexcept}, even if it is known never to throw an exception for a \emph{valid} combination of input values and accessible state. When a function having a narrow contract is obliged not to throw, the function should merely be specified as ``Throws: nothing'', but not declared \tcode{noexcept}. This allows for highly effective testing strategies that involve throwing exceptions as a way of diagnosing \emph{contract violations} --- i.e., bugs introduced by calling the function with an invalid combination of input values and accessible state (calling the function \emph{out of contract}). This design principle is also known as the \emph{Lakos Rule}.

The Lakos Rule was first proposed in \cite{N3248} and adopted with \cite{N3279}. An updated version of the rule was codified into policy in \cite{P0884R0}. See \cite{O'Dwyer2018} for a more detailed summary.

More recently, \cite{P1656R2} argued that the Lakos Rule should be abandoned as a design principle. According to this paper, functions that are known to never throw an exception for a \emph{valid} combination of input values and accessible state should always be declared \tcode{noexcept}, regardless of whether they have a wide or a narrow contract. Further, \cite{P2148R0} proposed adopting a new standing document with design guidelines for the evolution of the C++ Standard Library that move away from the Lakos Rule.

In section \ref{sec:casestudy} of this paper, we present a case study to demonstrate that the Lakos Rule is still useful and important today because it can help detect and prevent bugs in different kinds of code bases. In section \ref{sec:contracts}, we argue further that a C++ Contracts facility might offer a superior solution to the problem of testing for contract violations and that we might want to reconsider the Lakos Rule \emph{after} we have standardised such a facility; we should not, however, remove the Lakos Rule before standardising Contracts, since no viable alternative is currently available for cross-platform codebases that rely on the Lakos Rule to test for contract violations.

\section{Case Study}
\label{sec:casestudy}

\subsection{The premise}

In 2018, I co-founded the music technology company Cradle (\hyperref[https://cradle.app]{\tcode{https://cradle.app}}) and became its CTO. I was in the enviable position of being able to start a brand new code base from scratch, following the latest modern C++ best practices. I also hired a brand new developer team. We had the freedom to introduce whatever software technology and coding guidelines made the most sense for the goals we set out to accomplish.

From the start, the core guiding principle for building Cradle's software stack and engineering culture was a strong focus on code quality. One of the ideals we introduced to achieve this goal is to aim for a high unit test coverage. For whatever reason, focusing on automated testing in general, and unit testing in particular, tends to be less common in  music production software than in other industries. We learned in practice that, by having a strong culture of unit testing and test-driven development (TDD), we were able to deliver software at a significantly higher quality standard, with far fewer bugs and crashes reported by users. The parts of our codebase where TDD proved to be particularly effective were the foundational, generic C++ libraries that the rest of the codebase relied upon. In general, whenever feasible, we aim for every line of product code to have some corresponding test code.

\subsection{The problem}

As we started practicing TDD with modern C++ however, we immediately ran into a problem. Let us consider an example C++ function (a very typical function for a foundational audio software library):
\begin{codeblock}
float fast_log(float x);  // efficiently computes the base e logarithm of x
\end{codeblock}

This function is specified to have a narrow contract: It has a precondition that \tcode{x >= 0}. If this precondition is violated, the behaviour is undefined; this specification is necessary to achieve maximum performance in a release build. Calling \tcode{fast_log} with an argument value of less than \tcode{0} is therefore unconditionally a bug.

Now, writing unit tests to ensure that this function returns the correct result for valid input is straightforward:
\begin{codeblock}
CHECK_APPROX_EQUAL(fast_log(1), 0);
\end{codeblock}
In this example, \tcode{CHECK_APPROX_EQUAL} is some macro provided by the unit test framework, checking that two floating-point numbers are approximately equal within some specified tolerance. But this is not the only kind of unit tests that we need to write. We also need to ensure that the function behaves as intended when called out of contract.

In our case, the intended behaviour for invalid input is that (1) in debug mode, the precondition \tcode{x >= 0} should be checked and a contract violation should trigger an assertion failure, and (2) in release mode, the precondition should be ignored and a contract violation would, in general, lead to undefined behaviour. Checking the precondition in debug mode is critically important since otherwise the developer might not realise they have called \tcode{fast_log} out of contract and could introduce a new bug to the code base.

Let us go ahead and add this precondition check. C++23 lacks a language-level Contracts facility, so we need to use a library-based solution, typically some form of \tcode{ASSERT} macro: 
\begin{codeblock}
float fast_log(float x) {
  ASSERT(x >= 0);
  // implementation
}
\end{codeblock}
In this example, \tcode{ASSERT} is a macro that prints a diagnostic and aborts the program in a debug build and does nothing in a release build.\footnote{Our codebase includes a third case: When a debugger is attached, the macro calls a function that causes the debugger to break, very similar to \tcode{std::breakpoint()} as proposed in \cite{P2514R0}. This situation is one of the reasons why our codebase, like many other codebases, has a custom \tcode{ASSERT} macro rather than simply using the \tcode{assert} macro from the standard header \tcode{cassert}.}

If we follow our principle that, whenever feasible, every line of product code should have some corresponding test code, then when adding such a precondition check to \tcode{fast_log}, we also need to write a unit test to ensure that the precondition check has in fact been added:
\begin{codeblock}
CHECK_ASSERT_FAIL(fast_log(-1));
\end{codeblock}
But how do we write such a test?

\subsection{Solution: The Lakos Rule}
Once we hit the \tcode{ASSERT} macro and the assertion fails, continuing to execute the body of the function is no longer meaningful; the code will either crash or lead to other forms of undefined behaviour. To continue running our unit test suite, we therefore need a way to exit the function (other than by returning a value) at the point where the \tcode{ASSERT} fails.

The most natural way to achieve this exit is to throw an exception, which is exactly why the Lakos Rule exists. Since \tcode{fast_log} has a narrow contract, we do not mark it as \tcode{noexcept}, and we can define our \tcode{ASSERT} macro:
\begin{codeblock}
#if NDEBUG
  #define ASSERT(expr)
#else
  #define ASSERT(expr) if (!expr) throw AssertFail();
#endif
\end{codeblock}
Then, we can define our \tcode{CHECK_ASSERT_FAIL} as checking that an exception of type \tcode{AssertFail} has been thrown; every modern C++ unit testing framework provides this functionality.

\subsection{Alternatives}

If we abandon the Lakos Rule as a design principle, as proposed in \cite{P1656R2} and \cite{P2148R0}, writing such tests (and, therefore, preventing bugs due to missing asserts) becomes much harder. Without the Lakos Rule, \tcode{fast_log} ought to be marked as \tcode{noexcept}, since this function is known to never throw when called with valid input. Writing the \tcode{ASSERT} and \tcode{CHECK_ASSERT_FAIL} macros as above thus becomes impossible: Throwing \tcode{AssertFail()} out of a function marked \tcode{noexcept} would call \tcode{std::terminate}, immediately bringing down the whole test suite. At Cradle, we experimented with the following workarounds, none of which were deemed satisfactory.

\subsubsection{Death tests}

To prevent \tcode{std::terminate} from bringing down the whole test suite, we can write our \tcode{CHECK_ASSERT_FAIL} as a death test. In a death test, the current process is forked, the code under test is run in the child process, and then the unit test framework checks that that child process has terminated abnormally, in which case the death test passes. This approach works in theory, but has several drawbacks.
\begin{itemize}
\item Most C++ unit test frameworks do not offer support for death tests. From the popular C++ unit test frameworks, only GoogleTest does, and Catch2, Boost.Test, CppTest, and DocTest do not. At Cradle, for various technical reasons, we ended up using Catch2, which means that death tests were unavailable to us.
\item We found death tests to have a significant runtime overhead when compared to unit tests that merely check whether an exception has been thrown. Running all unit tests takes orders of magnitude more time when using death tests, significantly slowing down the CI pipeline.
\item Death tests lose information: The unit test framework can verify that the child process has terminated abnormally but not whether this termination was actually caused by a contract violation (which is what we want to test).
\end{itemize}

\subsubsection{POSIX signals}

If we cannot use child processes and death tests and if we cannot use exceptions, another way to abort the execution of the function from our \tcode{ASSERT} macro and to signal a contract violation to our unit test framework is to raise a POSIX signal. This method works well on POSIX platforms; however, at Cradle, we are deploying cross-platform audio software that should run (and therefore be tested on) all of macOS, Linux, and Windows platforms. POSIX signals are unavailable on Windows, so this approach too is not viable.

\subsubsection{\tcode{setjmp} and \tcode{longjmp}}

Yet another way to abort the execution of the function from our \tcode{ASSERT} macro is to use \tcode{setjmp} and \tcode{longjmp}. However, this technique is not viable for the purposes of negative testing. In general\footnote{Notably, Microsoft's implementation of  \tcode{setjmp} and \tcode{longjmp} \emph{does} perform stack unwinding with local object destruction, as is done for \tcode{throw} and \tcode{catch}; see \cite{MSVCDocLongjmp}.}, when using \tcode{setjmp} and \tcode{longjmp} instead of \tcode{throw} and \tcode{catch}, the stack is not unwound and destructors of objects on the stack are not called. Per [csetjmp.syn], the behaviour is undefined if unwinding of the stack would have resulted in calls to non-trivial destructors:

\begin{adjustwidth}{0.5cm}{0.5cm}
The contents of the header \tcode{<csetjmp>} are the same as the C standard library header \tcode{<setjmp.h>}.

The function signature \tcode{longjmp(jmp_­buf jbuf, int val)} has more restricted behavior in this document. A \tcode{setjmp}/\tcode{longjmp} call pair has undefined behavior if replacing the \tcode{setjmp} and \\ \tcode{longjmp} by \tcode{catch} and \tcode{throw} would invoke any non-trivial destructors for any objects with automatic storage duration.
\end{adjustwidth}

This means that we will immediately run into undefined behaviour when performing negative testing of any code involving objects with non-trivial destructors, which is the case for most C++ code. But even if the behaviour would be defined, if we run thousands of unit tests involving data structures that allocate significant amounts of memory on the heap, we end up with an unacceptable amount of memory leaks. We will also break the program logic in the presence of other resources that rely on RAII, such as \tcode{std::lock_guard}.

\subsubsection{Making \tcode{noexcept} conditional on whether we are in unit test mode}

Another workaround that we used at Cradle was our method of introducing a macro:
\begin{codeblock}
#if UNIT_TEST_MODE
  #define NOEXCEPT 
#else
  #define NOEXCEPT noexcept
#endif
\end{codeblock}
Then, we can mark all functions with a narrow contract with this \tcode{NOEXCEPT} macro rather than the \tcode{noexcept} keyword and compile the library with \tcode{-DUNIT_TEST_MODE=1} for the purposes of running unit tests. However, this option is also unsatisfactory because, in this way, we effectively end up unit testing not our actual code but code that is compiled differently and results in a different binary with different behaviour. Software engineering best practice fairly demands that the code that is built for production be tested directly.

\section{Contracts}
\label{sec:contracts}

SG21 is currently working on standardising a \emph{Contracts facility} --- i.e., a new language feature to be added to the C++ Standard --- that allows the user to express preconditions, postconditions, and assertions in C++ code. Attempts to standardise a Contracts facility have a long history; according to the current SG21 roadmap \cite{P2695R1}, we are aiming to get a Contracts MVP into C++26. See \cite{P2521R3} and references therein for a summary of the current state of this effort.

With the Contracts MVP, we will thus be able to express the precondition of \tcode{fast_log}. SG21 has currently not yet decided on the syntax; in this paper, we will use one of the three options for syntax currently under consideration, the so-called ``attribute-like'' syntax:
\begin{codeblock}
float fast_log(float x) [[ pre: x >= 0 ]];
\end{codeblock}

The current Contracts MVP proposes two build modes: \emph{No_eval}, in which the precondition is ignored, and \emph{Eval_and_abort}, in which the precondition is checked; if the predicate evaluates to \tcode{false}, \tcode{std::terminate} is called. At first, we seem to have gained little for purposes of testing for contract violations: Calling \tcode{fast_log} out of contract will result in \tcode{std::terminate} being called, which leaves death tests as the only viable method to write tests for such a call.

The Contracts MVP is, however, merely a first step toward having a full-featured standardised Contracts facility. The Contracts MVP is explicitly designed to be extended, such as by adding custom violation handlers (\cite{P2698R0}, \cite{P2811R0}) or other facilities (\cite{P2784R0}) that allow us to test out-of-contract calls without relying on the function under test not being marked as \tcode{noexcept}. Even if we get only the current Contracts MVP --- i.e., without custom violation handlers or similar facilities --- in C++26, the Contracts MVP is explicitly designed to allow compiler vendors to offer additional build modes in which such behaviour can be configured. In either case, we will have a superior way to test for contract violations, and we will no longer need the Lakos Rule to enable this testing. As long as such a Contracts facility is not part of the C++ Standard, however, no adequate replacement for the Lakos Rule is available. We should, therefore, retain the Lakos Rule in the Standard Library design guidelines.

\section{Conclusion}
At Cradle, we found that testing our code for contract violations has proven to be an important part of keeping our code quality high and reducing the number of introduced bugs. We also found that, out of all methods to achieve this kind of testing, the Lakos Rule is the most straightforward and effective method and offers the most favourable tradeoffs. 

We experimented with using death tests, POSIX signals, and \tcode{setjmp} and \tcode{longjmp} and with making \tcode{noexcept} conditional on whether we are in unit test mode. We found that all these alternative approaches have worse tradeoffs than following the Lakos Rule for our use cases.

Since the Lakos Rule works so well for foundational C++ libraries in the cross-platform software space, assuming that it would also be a viable approach for at least some implementations of the C++ Standard Library is a reasonable assumption. We therefore urge the C++ committee to retain the Lakos Rule as a design principle for the Standard Library, at least until we standardise a Contracts facility in C++.

A standard C++ Contracts facility might provide a superior way to test a codebase for contract violations, at which point the Lakos Rule might no longer be needed in its current form. However, changing our library design guidelines and removing the Lakos Rule should be considered only at that point, not while no such superior facility for testing contract checks exists in the C++ Standard.

%\section*{Document history}

%\begin{itemize}
%\item \textbf{R0}, 2023-03-08: Initial version.
%\item \textbf{R1}, 20XX-XX-XX: ??
%\end{itemize}

\section*{Acknowledegments}

We would like to thank Lori Hughes for proofreading a draft of this paper.

\renewcommand{\bibname}{References}
\bibliographystyle{abstract}
\bibliography{ref}

\end{document}