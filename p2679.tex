\input{wg21common}

\newcommand{\forceindent}{\parindent=1em\indent\parindent=0pt\relax} % For indenting a paragraph containing code that can't be laid out as a {codeblock} because it also contains \emph

\begin{document}
\title{Fixing \tcode{std::start_lifetime_as} for arrays}
\author{
  Timur Doumler \small(\href{mailto:papers@timur.audio}{papers@timur.audio}) \\
  Arthur O'Dwyer \small(\href{mailto:arthur.j.odwyer@gmail.com}{arthur.j.odwyer@gmail.com}) \\
  Richard Smith \small(\href{mailto:richardsmith@google.com}{richardsmith@google.com})
}
\date{}
\maketitle

\begin{tabular}{ll}
Document \#: & P2679R0 \\
Date: & 2022-10-15\\
Project: & Programming Language C++ \\
Audience: & Library Evolution Working Group, Library Working Group
\end{tabular}


\begin{abstract}
\tcode{std::start_lifetime_as}, a facility to explicitly start the lifetime of an object of implicit-lifetime type inside a block of suitably aligned storage, was introduced in \cite{P2590R2} and voted into C++23. However, it has since emerged that for array types, the current API is broken and inconsistent. This paper proposes the necessary fixes.
\end{abstract}

\section{The problem}
\label{sec:problem}

\cite{P2590R2} introduced a set of overloads that works for non-array types and array types of known bound, called \tcode{std::start_lifetime_as}, and a separate set of overloads for array types of unknown bound, called  \tcode{std::start_lifetime_as_array}, using a different name with the \tcode{_array} suffix.

This API is inconsistent with other APIs in the standard library that create objects and accept both array and non-array types, such as \tcode{std::make_shared} and \tcode{std::make_unique}. These have a version for non-array types, a version for array types of known bound, and a version for array types of unknown bound, respectively, all with the same name.

Further, the current naming is also inconsistent with itself in multiple ways: the overloads that work for arrays of \emph{unknown} bound have the suffix \tcode{_array} in the name, but the overloads that work for arrays of \emph{known} bound do not. This does not make any sense and is highly confusing for users.

In the same way that the naming is inconsistent with existing standard APIs and also with itself, the template parameters are also inconsistent. For \tcode{std::start_lifetime_as}, when used with an array type \tcode{U[N]} of known bound, the template argument that the user needs to provide is the type \tcode{U[N]} of the object being created (for example, \tcode{std::start_lifetime_as<int[16]>}), while for \tcode{std::start_lifetime_as_array}, the template argument is not the type \tcode{U[]} of the object being created, but the type of its elements \tcode{U}.

Finally, the overloads for arrays of \emph{unknown} bound (the ones with the suffix \tcode{_array}) return a pointer to the first element of the array, while the overloads without the suffix \tcode{_array}, when used with an array type of known bound, return a pointer to the array itself. In other words, a call to \tcode{std::start_lifetime_as_array<int>(p, 16)} will return an \tcode{int*}, but at the same time a call to \tcode{std::start_lifetime_as<int[16]>(p)} will return an \tcode{int(*)[16]}, which makes creating and using arrays with this facility very awkward and unintuitive.

\section{Proposed solution}
\label{sec:solution}

We propose to fix the specification of \tcode{std::start_lifetime_as} as follows:

\begin{itemize}
\item Add wording to the existing \tcode{std::start_lifetime_as<T>} overloads mandating that \tcode{T} is not an array type.
\item Add new \tcode{std::start_lifetime_as<T>} overloads, for the case that \tcode{T} is an array type of known bound \tcode{U[N]}. These should work exactly like the non-array overloads, except that instead of returning a pointer to the array, they return a pointer to the first element.
\item For array types of unknown bound, remove the existing \mbox{\tcode{std::start_lifetime_as_array<U>}} overloads and replace them with \tcode{std::start_lifetime_as<T>} overloads, where \tcode{T} is the type \tcode{U[]} and otherwise the functionality is the same.
\end{itemize}

This leaves us with a single overload set that covers all three cases (non-arrays, arrays of known bound, and arrays of unknown bound). This is clean, user-friendly, and consistent with other APIs in the standard library that create objects and accept both array and non-array types, such as \tcode{std::make_shared} and \tcode{std::make_unique}.

In each case, the name of the function is \tcode{std::start_lifetime_as}, the template parameter is the type of the object being created, and the return value is either a pointer to the object being created (for non-arrays) or to its first element (for arrays).

We consider this proposal a critical bugfix for \tcode{std::start_lifetime_as}. We therefore strongly recommend that it should be adopted in the C++23 timeframe, and that \tcode{std::start_lifetime_as} should not be shipped without this bugfix applied.

This proposal fixes a submitted NB comment targeting C++23.

\section{Tony table}

\begin{tabular}{|l|l|}
\hline
\textbf{Before}  &  \textbf{After} \\
\hline
\footnotesize
\begin{lstlisting}[basicstyle=\footnotesize \ttfamily]
unsigned char* buf = /* ... */;

int* p1 = std::start_lifetime_as<int>(buf);
int(* p2)[10] = std::start_lifetime_as<int[10]>(buf);
int* p3 = std::start_lifetime_as_array<int>(buf, 10);
\end{lstlisting}&
\begin{lstlisting}[basicstyle=\footnotesize \ttfamily]
unsigned char* buf = /* ... */;

int* p1 = std::start_lifetime_as<int>(buf);
int* p2 = std::start_lifetime_as<int[10]>(buf);
int* p3 = std::start_lifetime_as<int[]>(buf, 10);
\end{lstlisting} \\
\hline
\end{tabular} 

\section{Design considerations}
\label{sec:design}

The design intent is that using the wrong interface with the wrong type should lead to a compile error: \tcode{std::start_lifetime_as<int[]>(buf)}, \tcode{std::start_lifetime_as<int>(buf, 10)}, and \tcode{std::start_lifetime_as<int[10]>(buf, 10)} should all be ill-formed and not necessarily SFINAE-friendly, and the same should be true for using either interface with a non-implicit-lifetime type. Simultaneously, the version for non-arrays and the one for arrays with known bound have the same function signatures (apart from the return type), so they need to coexist in such a way that the correct one is selected when used correctly. We therefore need to specify the correct combination of \emph{Mandates:} and \emph{Constraints:} clauses to achieve this.

Each of the three versions (non-arrays, arrays with known bound, and arrays with unknown bound) also still needs to contain four overloads for completeness: for \tcode{T*}, \tcode{const T*}, \tcode{volatile T*}, and \tcode{const volatile T*}, respectively. The complete overload set thus now contains 12 functions (up from 8 previously). To reduce the amount of overloads and avoid the combinatorial explosion, we considered an alternative approach: have only one overload per version but the parameter is restricted to \tcode{is_void}. However, that approach would forbid conversions. This would render the API difficult to use: in practice, the argument is rarely a \tcode{void*}, but typically a pointer to storage such as an \tcode{unsigned char*} or a \tcode{std::byte*}. We therefore rejected such an approach as unviable.


\section{Proposed wording}
\label{sec:wording}

The proposed changes are relative to the C++ working paper \cite{N4917}.

Modify header \tcode{<memory>} synopsis [memory.syn] as follows:

%\begin{adjustwidth}{0.5cm}{0.5cm}

\begin{codeblock}
// [obj.lifetime] Explicit lifetime management
\end{codeblock}
\begin{removedblock}
\begin{codeblock}
template<class T>
  T* start_lifetime_as(void* p) noexcept;
template<class T>
  const T* start_lifetime_as(const void* p) noexcept;
template<class T>
  volatile T* start_lifetime_as(volatile void* p) noexcept;
template<class T>
  const volatile T* start_lifetime_as(const volatile void* p) noexcept;
template<class T>
  T* start_lifetime_as_array(void* p, size_t n) noexcept;
template<class T>
  const T* start_lifetime_as_array(const void* p, size_t n) noexcept;
template<class T>
  volatile T* start_lifetime_as_array(volatile void* p, size_t n) noexcept;
template<class T>
  const volatile T* start_lifetime_as_array(const volatile void* p, size_t n) noexcept;
\end{codeblock}
\end{removedblock}

\begin{addedblock}
\begin{codeblock}
template<class T>
  T* start_lifetime_as(void* p) noexcept;                               // \tcode{T} is not array
template<class T>
  const T* start_lifetime_as(const void* p) noexcept;                   // \tcode{T} is not array
template<class T>
  volatile T* start_lifetime_as(volatile void* p) noexcept;             // \tcode{T} is not array
template<class T>
  const volatile T* start_lifetime_as(const volatile void* p) noexcept; // \tcode{T} is not array
template<class T>
  U* start_lifetime_as(void* p) noexcept;                               // \tcode{T} is \tcode{U[N]}
template<class T>
  const U* start_lifetime_as(const void* p) noexcept;                   // \tcode{T} is \tcode{U[N]}
template<class T>
  volatile U* start_lifetime_as(volatile void* p) noexcept;             // \tcode{T} is \tcode{U[N]}
template<class T>
  const volatile U* start_lifetime_as(const volatile void* p) noexcept; // \tcode{T} is \tcode{U[N]}
template<class T>
  U* start_lifetime_as(void* p, size_t n) noexcept;                     // \tcode{T} is \tcode{U[]}
template<class T>
  const U* start_lifetime_as(const void* p, size_t n) noexcept;         // \tcode{T} is \tcode{U[]}
template<class T>
  volatile U* start_lifetime_as(volatile void* p, size_t n) noexcept;   // \tcode{T} is \tcode{U[]}
template<class T>
  const volatile U* start_lifetime_as(const volatile void* p, size_t n) noexcept; 
                                                                        // \tcode{T} is \tcode{U[]}
\end{codeblock}
\end{addedblock}
%\end{adjustwidth}

Modify [obj.lifetime] as follows:

\textbf{Explicit lifetime management \hspace{83mm}[obj.lifetime]}

\begin{codeblock}
template<class T>
  T* start_lifetime_as(void* p) noexcept;
template<class T>
  const T* start_lifetime_as(const void* p) noexcept;
template<class T>
  volatile T* start_lifetime_as(volatile void* p) noexcept;
template<class T>
  const volatile T* start_lifetime_as(const volatile void* p) noexcept;
\end{codeblock}

\begin{adjustwidth}{0.5cm}{0.5cm}
\added{\emph{Constraints:} \tcode{T} is not an array type.}

\emph{Mandates:} \tcode{T} is an implicit-lifetime type.

\emph{Preconditions:} [\tcode{p}, \tcode{(char*)p + sizeof(T)}) denotes a region of allocated storage that is a subset of the region of storage reachable through ([basic.compound]) \tcode{p} and suitably aligned for the type \tcode{T}.

\emph{Effects:} Implicitly creates objects ([intro.object]) within the denoted region as follows: an object $a$ of type \tcode{T}, whose address is \tcode{p}, and objects nested within $a$. The object representation of $a$ is the contents of the storage prior to the call to \tcode{start_lifetime_as}. The value of each created object $o$ of trivially-copyable type \tcode{U} is determined in the same manner as for a call to \tcode{bit_cast<U>(E)} ([bit.cast]), where \tcode{E} is an lvalue of type \tcode{U} denoting $o$, except that the storage is not accessed. The value of any other created object is unspecified. \begin{note}The unspecified value can be indeterminate.\end{note}

\emph{Returns:} A pointer to $a$.
\end{adjustwidth}

\begin{addedblock}
\begin{codeblock}
template<class T>
  U* start_lifetime_as(void* p) noexcept;
template<class T>
  const U* start_lifetime_as(const void* p) noexcept;
template<class T>
  volatile U* start_lifetime_as(volatile void* p) noexcept;
template<class T>
  const volatile U* start_lifetime_as(const volatile void* p) noexcept;
\end{codeblock}

\begin{adjustwidth}{0.5cm}{0.5cm}

\emph{Constraints:} \tcode{T} is an array type of known bound \tcode{U[N]}.

\emph{Effects:} Equivalent to \tcode{start_lifetime_as<T>(p)} for non-array types, except that the return value is a pointer to the first element of $a$.
\end{adjustwidth}
\end{addedblock}

\begin{removedblock}
\begin{codeblock}
template<class T>
  T* start_lifetime_as_array(void* p, size_t n) noexcept;
template<class T>
  const T* start_lifetime_as_array(const void* p, size_t n) noexcept;
template<class T>
  volatile T* start_lifetime_as_array(volatile void* p, size_t n) noexcept;
template<class T>
  const volatile T* start_lifetime_as_array(const volatile void* p, size_t n) noexcept;
\end{codeblock}
\end{removedblock}
\begin{addedblock}
\begin{codeblock}
template<class T>
  U* start_lifetime_as(void* p, size_t n) noexcept;
template<class T>
  const U* start_lifetime_as(const void* p, size_t n) noexcept;
template<class T>
  volatile U* start_lifetime_as(volatile void* p, size_t n) noexcept;
template<class T>
  const volatile U* start_lifetime_as(const volatile void* p, size_t n) noexcept;
\end{codeblock}
\end{addedblock}

\begin{adjustwidth}{0.5cm}{0.5cm}
\added{\emph{Mandates:} \tcode{T} is an array type of unknown bound \tcode{U[]}.}

\emph{Preconditions:} \tcode{n > 0} is \tcode{true}.

\emph{Effects:} Equivalent to: \tcode{return \removed{*start_lifetime_as<U>(p)}\added{start_lifetime_as<V>(p)};} where \tcode{\removed{U}\added{V}} is the type ``array of \tcode{n} \tcode{U}''.
\end{adjustwidth}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pagebreak % MANUAL

\section*{Acknowledgements}
Many thanks to Daniel Kr\" ugler and Peter Dimov for their valuable comments on the LWG reflector regarding this issue.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\renewcommand{\bibname}{References}
\bibliographystyle{abstract}
\bibliography{ref}

\end{document}